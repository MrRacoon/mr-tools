import { Name } from 'mr-types';
import { AnyAction } from 'redux';
import { EmptyAction, PayloadAction, Type } from './types';

// =============================================================================

export type SetRootAction = PayloadAction<Type.SET_ROOT, string>;
export const setRoot = (rootPath: string): SetRootAction => ({
  type: Type.SET_ROOT,
  payload: rootPath,
});

// =============================================================================

export type SetSubsAction = PayloadAction<Type.SET_SUBS, string[]>;
export const setSubs = (subs: string[]): SetSubsAction => ({
  type: Type.SET_SUBS,
  payload: subs,
});

// =============================================================================

export type SetPackageFocus = PayloadAction<Type.SET_FOCUS, string>;
export const setFocus = (packageName: Name): SetPackageFocus => ({
  type: Type.SET_FOCUS,
  payload: packageName,
});

// =============================================================================
// OtherAction is a standin that helps typscript understand that there may be
// messages flowing through redux that we don't handle. Typescsript will now
// think the default case in our reudcer is to handle OtherAction, but really
// it's for all the other actions.
export type OtherAction = EmptyAction<Type.UNDEFINED>;

// =============================================================================

export type Actions
  = SetRootAction
  | SetSubsAction
  | SetPackageFocus
  | OtherAction;
