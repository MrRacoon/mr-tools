import blessed from 'blessed';
import contrib from 'blessed-contrib';
import * as command from 'mr-command';
import { config } from 'mr-config';
import { actions, Actions, Model, select } from 'mr-state';
import { Name, PackageJson } from 'mr-types';
import _ from 'ramda';
import { Dispatch, Store } from 'redux';

const debug = config.verbose;

export default function(store: Store<Model>) {
  // ===========================================================================
  // MainScreen and Grid objects

  const screen = blessed.screen();
  const grid = new contrib.grid({
    screen,
    rows: 12,
    cols: 12,
  });

  // ===========================================================================
  // Application logger

  const logger = grid.set(0, 4, 12, 8, contrib.log, {
    label: 'Master Logger',
    fg: 'cyan',
    style: {
      border: {
        fg: 'white',
      },
    },
    mouse: true,
    scrollable: true,
    interactive: true,
    bufferLength: 100,
    vi: true,
  });

  // ===========================================================================
  // List of Options

  const options = grid.set(0, 0, 4, 2, contrib.tree, {
    label: 'Options',
    fg: 'green',
    vi: true,
    style: {
      fg: 'white',
      border: {
        fg: 'white',
      },
      selected: {
        bg: 'yellow',
        fg: 'black',
      },
    },
    template: {
      lines: true,
    },
    mouse: true,
    keys: [ 'space', 'enter', 'l', '+' ],
  });

  options.on('select', (node: Node) => {
    if (debug) {
      logger.log(`Selected: ${node.name}`);
    }
    const state = store.getState();
    const cwd = select.getFocusedPackagePath(state);
    if (cwd) {
      let com;
      switch (node.name) {
        case 'Build':
          logger.log(`Running build in ${cwd}`);
          com  = command.runInPackage(cwd, 'ls');
          break;
        case 'Lint':
          logger.log(`Running linter in ${cwd}`);
          com  = command.runNpmInPackage(cwd, 'lint');
          break;
        case 'Cover':
          logger.log(`Running coverage in ${cwd}`);
          com  = command.runNpmInPackage(cwd, 'coverage');
          break;
        default:
          com = Promise.reject(`Unhandled command ${node.name}`);
          break;
      }
      com.then(([out, err]) => {
        logger.log('Command Succeeded');
        if (out) {
          out.split('\n').forEach((line) => {
            logger.log(line);
          });
        }
        if (err) {
          err.split('\n').forEach((line) => {
            logger.log(line);
          });
        }
      })
      .catch((err) => {
        logger.log('Command Failed');
        err
          .toString()
          .split('\n')
          .forEach((line: string) => {
            logger.log(line);
          });
      });
    }
  });

  options.setData({
    extended: true,
    children: {
      Lint: {},
      Build: {},
      Cover: {},
    },
  });

  // ===========================================================================
  // List of package names

  const name = grid.set(4, 0, 8, 2, contrib.tree, {
    label: 'Package Names',
    fg: 'green',
    vi: true,
    style: {
      fg: 'white',
      border: {
        fg: 'white',
      },
      selected: {
        bg: 'yellow',
        fg: 'black',
      },
    },
    template: {
      lines: true,
    },
    mouse: true,
    keys: [ 'space', 'enter', 'l', '+' ],
  });

  name.setData({
    extended: true,
    children: select.getSubPackageNames(store.getState())
      .reduce(
        (obj, pkgName: string) => ({ ...obj, [pkgName]: {} }),
        {},
      ),
  });

  // ===========================================================================
  // Focussed Package

  const focussed = grid.set(0, 2, 12, 2, contrib.tree, {
    label: 'Focussed Package',
    style: {
      fg: 'yellow',
      selected: {
        bg: false,
        fg: 'yellow',
      },
      border: {
        fg: 'white',
      },
    },
    vi: true,
    keys: [],
    template: {
      extend: ' ',
      retract: ' ',
      lines: true,
    },
  });

  function expandJson(json: object): object {
    return _.mapObjIndexed((val, key) => {
      if (Array.isArray(val)) {
        if (debug) { logger.log(`${key} is array`); }
        return {
          extended: true,
          children: _.reduce((obj, v) => {
            return {
              ...obj,
              [v]: {},
            };
          } , {}, val),
        };
      }
      if (typeof val === 'object') {
        if (debug) { logger.log(`${key} is object`); }
        return {
          extended: true,
          children: expandJson(val),
        };
      }
      if (debug) { logger.log(`${key} is val ${val}`); }
      return {
        extended: true,
        children: {
          [val]: {},
        },
      };
    }, json);
  }

  function setFocus(state: Model) {
    const focussedPackage = select.getFocusedPackageJson(state);
    if (focussedPackage) {
      focussed.setData({
        extended: true,
        children: expandJson(focussedPackage),
      });
    }
  }

  // ===========================================================================
  // Events

  interface Node {
    name: string;
  }

  name.on('select', (node: Node) => {
    if (debug) {
      logger.log(`Selected: ${node.name}`);
    }
    store.dispatch(actions.setFocus(node.name));
    setFocus(store.getState());
    screen.render();
  });

  // ===========================================================================
  // KeyBindings
  screen.key('a', () => options.focus());
  screen.key('s', () => name.focus());
  screen.key('f', () => logger.focus());
  screen.key(
    [ 'escape', 'q', 'C-c' ],
    (ch, key) => process.exit(0),
  );

  // ===========================================================================
  // Last Minute adjustments

  // Set initial focus to be the package list.
  name.focus();

  // Drop a message in the master logger.
  logger.log('Rendering Screen');

  // Call render.
  screen.render();

  // Return pointers to each view.
  return { screen, grid, focussed, name };
}
